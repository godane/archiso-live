#!/bin/bash
# Tazpkg - Tiny autonomous zone packages manager.
#
# This is a lightwight packages manager for *.tazpkg files, all written in
# SHell script. It works well with Busybox ash shell and bash. Tazpkg lets you
# list, install, remove, download or get information about a package. You can
# use 'tazpkg usage' to get a list of commands with short descriptions. Tazpkg
# also resolves dependencies and can upgrade packages from a mirror.
#
# (C) 2007-2010 SliTaz - GNU General Public License v3.
#
# Authors : Christophe Lincoln <pankso@slitaz.org>
#           Pascal Bellard <pascal.bellard@slitaz.org>
#           Eric Joseph-Alexandre <erjo@slitaz.org>
#           Paul Issott <paul@slitaz.org>
#           Rohit Joshi <jozee@slitaz.org>
#
VERSION=3.2.2

####################
# Script variables #
####################
# Auto-installation of packages dependencies.
AUTO_INSTALL_DEPS="yes"

# Path to all packages meta files (lists, receipt, desc).
LOCALSTATE="/var/lib/tazpkg"

# Path to Tazpkg log file.
LOG="/var/log/tazpkg.log"

# Path to the temporary directory used to extract package.
TMP_DIR="/tmp/tazpkg-$$-$RANDOM"

# Packages categories.
CATEGORIES="
base-system
x-window
utilities
network
graphics
multimedia
office
development
system-tools
security
games
misc
meta
non-free"

#if [ -f /etc/slitaz/tazpkg.conf
#	source /etc/slitaz/tazpkg.conf
#fi

if [ -f /etc/slitaz-release ]; then
	RELEASE=$(cat /etc/slitaz-release)
else
	RELEASE=$(cat ${LOCALSTATE}/slitaz-release)
fi

# Path to downloaded packages by get-intall command.
CACHE_DIR="/var/cache/tazpkg/${RELEASE}"

# Initialize some variables to use words rather than numbers for functions
# and actions.
COMMAND=$1
if [ -f "$2" ]; then
	# Set pkg basename for install, extract
	PACKAGE=$(basename ${2%.tazpkg} 2>/dev/null)
else
	# Pkg name for remove, search and all other cmds
	PACKAGE=${2%.tazpkg}
fi
PACKAGE_FILE=$2
TARGET_DIR=$3
TOP_DIR=`pwd`
INSTALL_LIST=""

# Path to tazpkg used dir and configuration files
INSTALLED=$LOCALSTATE/installed
MIRROR=$LOCALSTATE/mirror
BLOCKED=$LOCALSTATE/blocked-packages.list
DEFAULT_MIRROR="http://mirror.slitaz.org/packages/${RELEASE}/"
#DEFAULT_MIRROR="http://download.tuxfamily.org/slitaz/packages/${RELEASE}/"
LOCAL_REPO=""

# Messages language setting --> line 230.
case $LANG in
	fr*)
		#. /usr/share/slitaz/messages/fr/tazpkg.msg
		# Bold red warning for upgrade.
		WARNING="\\033[1;31mATTENTION\\033[0;39m"
		CHECK_FOR_PACKAGE_FILE_MSG="Impossible de trouver"
		CHECK_FOR_RECEIPT_MSG="Impossible de trouver la receipt"
		CHECK_FOR_INSTALLED_PACKAGE_MSG="\
$PACKAGE est déjà installé. Vous pouvez utiliser l'option --forced pour
forcer l'installation ou supprimer le paquet et le réinstaller." ;;
	*)
		#. /usr/share/slitaz/messages/en/tazpkg.msg
		# Bold red warning for upgrade.
		WARNING="\\033[1;31mWARNING\\033[0;39m"
		CHECK_FOR_PACKAGE_FILE_MSG="Unable to find"
		CHECK_FOR_RECEIPT_MSG="Unable to find the receipt"
		CHECK_FOR_INSTALLED_PACKAGE_MSG="\
$PACKAGE is already installed. You can use the --forced option to force
installation or remove it and reinstall." ;;
esac

# Check if the directories and files used by Tazpkg
# exist. If not and user is root we create them.
if test $(id -u) = 0 ; then
	if [ ! -d "$CACHE_DIR" ]; then
		mkdir -p $CACHE_DIR
	fi
	if [ ! -d "$INSTALLED" ]; then
		mkdir -p $INSTALLED
	fi
	if [ ! -f "$LOCALSTATE/mirror" ]; then
		echo "$DEFAULT_MIRROR" > $LOCALSTATE/mirror
	fi
fi

####################
# Script functions #
####################

# Print the usage.
usage ()
{
	echo -e "SliTaz package manager - Version: $VERSION\n
\033[1mUsage:\033[0m tazpkg [command] [package|dir|pattern|list|cat|--opt] [dir|--opt]
       tazpkg shell\n
\033[1mCommands: \033[0m
  usage            Print this short usage.
  bugs             Show known bugs in packages.
  list             List installed packages on the system by category or all.
  xhtml-list       Create a xHTML list of installed packages.
  list-mirror      List all available packages on the mirror (--diff for new).
  info             Print information about a package.
  desc             Print description of a package (if it exists).
  list-files       List the files installed with a package.
  list-config      List the configuration files.
  search           Search for a package by pattern or name (options: -i|-l|-m).
  search-pkgname   Search on mirror for package having a particular file.
  search-file	   Search for file(s) in all installed packages files.
  install          Install a local (*.tazpkg) package (--forced to force).
  install-list     Install all packages from a list of packages.
  remove           Remove the specified package and all installed files.
  extract          Extract a (*.tazpkg) package into a directory.
  pack             Pack an unpacked or prepared package tree.
  recharge         Recharge your packages.list from the mirror.
  repack           Create a package archive from an installed package.
  repack-config    Create a package archive with configuration files.
  recompress       Rebuild a package with the better compression ratio.
  upgrade          Upgrade one or all installed/listed package(s) on the mirror.
  upgradeable      Build upgradeable packages list quickly.
  block|unblock    Block an installed package version or unblock it for upgrade.
  get              Download a package into the current directory.
  get-install      Download and install a package from the mirror.
  get-install-list Download and install a list of packages from the mirror.
  check            Verify consistency of installed packages.
  add-flavor       Install the flavor list of packages.
  install-flavor   Install the flavor list of packages and remove other ones.
  set-release      Change release and update packages.
  clean-cache      Clean all packages downloaded in cache directory.
  depends          Display dependencies tree.
  rdepends         Display reverse dependencies tree.
  convert          Convert a deb/rpm/tgz/arch package to a slitaz (.tazpkg).
  link             Link a package from another slitaz installation.
  setup-mirror     Change the mirror url configuration.
  list-undigest    List undigest mirrors.
  remove-undigest  Remove an undigest mirror.
  add-undigest     Add an undigest mirror.
  setup-undigest   Update an undigest mirror.
  reconfigure      Replay post install script from package."
}

# Status function with color (supported by Ash).
status()
{
	local CHECK=$?
	echo -en "\\033[70G[ "
	if [ $CHECK = 0 ]; then
		echo -en "\\033[1;33mOK"
	else
		echo -en "\\033[1;31mFailed"
	fi
	echo -e "\\033[0;39m ]"
	return $CHECK
}

# Check if user is root to install, or remove packages.
check_root()
{
	if test $(id -u) != 0 ; then
		echo -e "\nYou must be root to run `basename $0` with this option."
		echo -e "Please use 'su' and root password to become super-user.\n"
		exit 0
	fi
}

# Check for a package name on cmdline.
check_for_package_on_cmdline()
{
	if [ -z "$PACKAGE" ]; then
		echo -e "\nPlease specify a package name on the command line.\n"
		exit 0
	fi
}

# Check if the package (*.tazpkg) exist before installing or extracting.
check_for_package_file()
{
	if [ ! -f "$PACKAGE_FILE" ]; then
		echo -e "
$CHECK_FOR_PACKAGE_FILE_MSG : $PACKAGE_FILE\n"
		exit 0
	fi
}

# Check for the receipt of an installed package.
check_for_receipt()
{
	if [ ! -f "$1$INSTALLED/$PACKAGE/receipt" ]; then
		echo -e "\n$CHECK_FOR_RECEIPT_MSG : $1$INSTALLED/$PACKAGE/receipt\n"
		exit 0
	fi
}

# Get package name in a directory
package_fullname_in_dir()
{
	[ -f $2$1/receipt ] || return
	EXTRAVERSION=""
	. $2$1/receipt
	echo $PACKAGE-$VERSION$EXTRAVERSION
}

# Get package name that is already installed.
get_installed_package_pathname()
{
	for i in $2$INSTALLED/${1%%-*}*; do
		[ -d $i ] || continue
		if [ "$1" = "$(package_fullname_in_dir $i $2)" ]; then
			echo $i
			return
		fi
	done
}

# Check if a package is already installed.
check_for_installed_package()
{
	if [ -n "$(get_installed_package_pathname $PACKAGE $1)" ]; then
		echo -e "\n$CHECK_FOR_INSTALLED_PACKAGE_MSG\n"
		exit 0
	fi
}

# Check for packages.list to download and install packages.
check_for_packages_list()
{
	if [ ! -f "$LOCALSTATE/packages.list" ]; then
		if test $(id -u) = 0 ; then
			tazpkg recharge
		else
			echo -e "\nUnable to find the list : $LOCALSTATE/packages.list\n
You should probably run 'tazpkg recharge' as root to get the latest list of
packages available on the mirror.\n"
			exit 0
		fi
	fi
}

# get an already installed package from packages.equiv
equivalent_pkg()
{
	for i in $(grep -hs "^$1=" $LOCALSTATE/packages.equiv \
		   $LOCALSTATE/undigest/*/packages.equiv | sed "s/^$1=//"); do
		if echo $i | grep -q : ; then
			# format 'alternative:newname'
			# if alternative is installed then substitute newname
			if [ -f $2$INSTALLED/${i%:*}/receipt ]; then
				# substitute package dependancy
				echo ${i#*:}
				return
			fi
		else
			# if alternative is installed then nothing to install
			if [ -f $2$INSTALLED/$i/receipt ]; then
				# substitute installed package
				echo $i
				return
			fi
		fi
	done
	# if not found in packages.equiv then no substitution
	echo $1
}

# get a virtual package from packages.equiv
virtual_pkg()
{
	for i in $(grep -hs "^$1=" $LOCALSTATE/packages.equiv \
		   $LOCALSTATE/undigest/*/packages.equiv | sed "s/^$1=//"); do
		if echo $i | grep -q : ; then
			# format 'alternative:newname'
			# if alternative is installed then substitute newname
			if [ -f $2$INSTALLED/${i%:*}/receipt ]; then
				# substitute package dependancy
				echo ${i#*:}
				return
			fi
		else
			# unconditional substitution
			echo $i
			return
		fi
	done
}

# Get package filename available on the mirror
get_package_filename()
{
	local pkg
	pkg=$(grep -A 1 -sh "^$1$" $LOCALSTATE/packages.txt \
		$LOCALSTATE/undigest/*/packages.txt | tail -1)
	pkg=$(echo $pkg)
	[ -n "$pkg" ] && pkg=$(grep -sh "^$1-$pkg" \
		$LOCALSTATE/packages.list \
		$LOCALSTATE/undigest/*/packages.list | head -1)
	[ -n "$pkg" ] || pkg=$(grep -sh "^$1-[0-9]" \
		$LOCALSTATE/packages.list \
		$LOCALSTATE/undigest/*/packages.list | head -1)
	[ -n "$pkg" ] || pkg=$(grep -sh "^$1-.[\.0-9]" \
		$LOCALSTATE/packages.list \
		$LOCALSTATE/undigest/*/packages.list | head -1)
	if [ -z "$pkg" ]; then
		# Check for vitual package
		local equiv
		equiv=$(virtual_pkg $1)
		if [ "$equiv" != "$1" ]; then
			PACKAGE=$equiv
			get_package_filename $PACKAGE
			return
		fi
	fi
	echo $pkg
}

# Check for a package in packages.list. Used by get and get-install to grep
# package basename.
check_for_package_in_list()
{
	local filename
	local check_only
	check_only="$1"
	filename=$(get_package_filename $PACKAGE)
	if [ -n "$filename" ]; then
		PACKAGE=$filename
	else
		echo -e "\nUnable to find : $PACKAGE in the mirrored packages list.\n"
		[ -n "$check_only" ] && return 1
		exit 0
	fi
}

# Log this activity
log()
{
	local extra
	[ "$1" = "Installed" ] && \
	extra=" - $(grep $PACKAGE-$VERSION $LOCALSTATE/installed.md5 | awk '{ print $1 }')"
	[ -e $LOG ] || touch $LOG
	DATE=`date +'%F %T'`
	[ -w $LOG ] &&
	echo "$DATE - $1 - $PACKAGE ($VERSION$EXTRAVERSION)$extra" >> $LOG
}

# Download a file from this mirror
download_from()
{
	local i
	local mirrors
	mirrors="$1"
	shift
	for i in $mirrors; do
		case "$i" in
		http://*|ftp://*) wget -c $i$@ && break;;
		*) cp $i/$1 . && break;;
		esac
	done
}

# Download a file trying all mirrors
download()
{
	local i
	case "$1" in
	*.tazpkg)
		for i in $LOCALSTATE $LOCALSTATE/undigest/* ; do
			grep "^${1%.tazpkg}$" $i/packages.list || continue
			download_from "$(cat $i/mirror)" "$@" && return
		done
	esac
	for i in $(cat $MIRROR $LOCALSTATE/undigest/*/mirror 2> /dev/null); do
		download_from "$i" "$@" && break
	done
}

# Extract a package with cpio and gzip/lzma.
extract_package()
{
	echo -n "Extracting $PACKAGE... "
	cpio -idm < $PACKAGE.tazpkg && rm -f $PACKAGE.tazpkg
	echo -n "Extracting the pseudo fs... "
	if [ -f fs.cpio.lzma ]; then
		echo -n "(lzma) "
		unlzma -c fs.cpio.lzma | cpio -idm && rm fs.cpio.lzma
	else
		zcat fs.cpio.gz | cpio -idm && rm fs.cpio.gz
	fi
}

remove_with_path()
{
	local dir
	rm -f $1 2>/dev/null
	dir="$1"
	while [ "$dir" != "/" ]; do
		dir="$(dirname $dir)"
		rmdir $dir 2> /dev/null || break
	done
}

# This function installs a package in the rootfs.
install_package()
{
	ROOT=$1
	if [ -n "$ROOT" ]; then
		 # Get absolute path
		 ROOT=$(cd $ROOT; pwd)
	fi
	(
		# Create package path early to avoid dependencies loop
		mkdir -p $TMP_DIR
		( cd $TMP_DIR ; cpio -i receipt > /dev/null) < $PACKAGE_FILE
		. $TMP_DIR/receipt
		if grep -q ^pre_depends $TMP_DIR/receipt; then
			pre_depends $ROOT
		fi
		# keep modifers and file list on upgrade
		cp $ROOT$INSTALLED/$PACKAGE/modifiers \
		   $ROOT$INSTALLED/$PACKAGE/files.list $TMP_DIR 2> /dev/null
		rm -rf $ROOT$INSTALLED/$PACKAGE 2> /dev/null
		# Make the installed package data dir to store
		# the receipt and the files list.
		mkdir -p $ROOT$INSTALLED/$PACKAGE
		cp $TMP_DIR/modifiers $ROOT$INSTALLED/$PACKAGE 2> /dev/null
		cp $TMP_DIR/files.list $ROOT$INSTALLED/$PACKAGE 2> /dev/null
		rm -rf $TMP_DIR 2> /dev/null
		sed -i "/ $(basename $PACKAGE_FILE)$/d" \
			$ROOT$LOCALSTATE/installed.md5 2> /dev/null
		cd $(dirname $PACKAGE_FILE)
		md5sum $(basename $PACKAGE_FILE) >> $ROOT$LOCALSTATE/installed.md5
	)
	# Resolve package deps.
	check_for_deps $ROOT
	if [ ! "$MISSING_PACKAGE" = "" ]; then
		install_deps $ROOT
	fi
	mkdir -p $TMP_DIR
	[ -n "$INSTALL_LIST" ] && echo "$PACKAGE_FILE" >> $INSTALL_LIST-processed
	echo ""
	echo -e "\033[1mInstallation of :\033[0m $PACKAGE"
	echo "================================================================================"
	echo -n "Copying $PACKAGE... "
	cp $PACKAGE_FILE $TMP_DIR
	status
	cd $TMP_DIR
	extract_package
	SELF_INSTALL=0
	EXTRAVERSION=""
	CONFIG_FILES=""
	# Include temporary receipt to get the right variables.
	. $PWD/receipt
	cd $ROOT$INSTALLED
	if [ $SELF_INSTALL -ne 0 -a -n "$ROOT" ]; then
		echo -n "Checking post install dependencies... "
		[ -f $INSTALLED/$PACKAGE/receipt ]
		if ! status; then
			echo "Please run 'tazpkg install $PACKAGE_FILE' in / and retry."
			rm -rf $TMP_DIR
			exit 1
		fi
	fi
	# Get files to remove if upgrading
	if [ -f $PACKAGE/files.list ]; then
		while read file; do
			grep -q "^$file$" $TMP_DIR/files.list && continue
			for i in $(cat $PACKAGE/modifiers 2> /dev/null ;
			    grep -sl $PACKAGE */modifiers | cut -d/ -f1 ); do
				grep -q "^$file$" $i/files.list && continue 2
			done
			echo $file
		done < $PACKAGE/files.list > $TMP_DIR/files2remove.list
	fi
	# Remember modified packages
	{ check=false
	  for i in $(grep -v '\[' $TMP_DIR/files.list); do
		[ -e "$ROOT$i" ] || continue
		[ -d "$ROOT$i" ] && continue
		echo "- $i"
		check=true
	  done ; 
	  $check && for i in *; do 
	  	[ "$i" == "$PACKAGE" ] && continue
	  	awk "{ printf \"$i %s\\n\",\$1 }" < $i/files.list
	  done } | awk '
{
	if ($1 == "-" || file[$2] != "") {
		file[$2] = file[$2] " " $1
		if ($1 != "-") {
			if (pkg[$1] == "") all = all " " $1
			pkg[$1] = pkg[$1] " " $2
		}
	}
}
END {
	for (i = split(all, p, " "); i > 0; i--)
		for (j = split(pkg[p[i]], f, " "); j > 0; j--)
			printf "%s %s\n",p[i],f[j];
}
		' | while read dir file; do
		if grep -qs ^$dir$ $PACKAGE/modifiers; then
			# Do not overload an overloaded file !
			rm $TMP_DIR$file 2> /dev/null
			continue
		fi
		grep -qs ^$PACKAGE$ $dir/modifiers && continue
		if [ -s "$dir/volatile.cpio.gz" ]; then
			# We can modify backed up files without notice
			zcat $dir/volatile.cpio.gz | cpio -t 2> /dev/null | \
				grep -q "^${file#/}$" && continue
		fi
		echo "$PACKAGE" >> $dir/modifiers
	done

	cd $TMP_DIR
	cp receipt files.list $ROOT$INSTALLED/$PACKAGE
	# Copy the description if found.
	if [ -f "description.txt" ]; then
		cp description.txt $ROOT$INSTALLED/$PACKAGE
	fi
	# Copy the md5sum if found.
	if [ -f "md5sum" ]; then
		cp md5sum $ROOT$INSTALLED/$PACKAGE
	fi
	# Pre install commands.
	if grep -q ^pre_install $ROOT$INSTALLED/$PACKAGE/receipt; then
		pre_install $ROOT
	fi
	if [ -n "$CONFIG_FILES" ]; then
		# save 'official' configuration files
		echo -n "Saving configuration files for $PACKAGE... "
		for i in $CONFIG_FILES; do
			( cd fs ; find ${i#/} -type f )
		done | ( cd fs ; cpio -o -H newc | gzip -9 ) > \
			$ROOT$INSTALLED/$PACKAGE/volatile.cpio.gz
		# keep user configuration files
		for i in $CONFIG_FILES; do
			( cd fs ; find ${i#/} -type f )
		done | while read i; do
			[ -e $ROOT/$i ] || continue
			cp -a $ROOT/$i fs/$i
		done
		status
	fi
	echo -n "Installing $PACKAGE... "
	cp -a fs/* $ROOT/
	status
	if [ -s files2remove.list ]; then
		echo -n "Removing old $PACKAGE... "
		while read file; do
			remove_with_path $ROOT$file
		done < files2remove.list
		true
		status
	fi
	# Remove the temporary random directory.
	echo -n "Removing all tmp files... "
	cd .. && rm -rf $TMP_DIR
	status
	# Post install commands.
	if grep -q ^post_install $ROOT$INSTALLED/$PACKAGE/receipt; then
		post_install $ROOT
	fi
	cd $TOP_DIR
	echo "================================================================================"
	echo "$PACKAGE ($VERSION$EXTRAVERSION) is installed."
	echo ""
	# Log this activity
	[ -n "$ROOT" ] || log Installed
}

# Check for loop in deps tree.
check_for_deps_loop()
{
	local list
	local pkg
	local deps
	pkg=$1
	shift
	[ -n "$1" ] || return
	list=""
	# Filter out already processed deps
	for i in $@; do
		case " $ALL_DEPS" in
		*\ $i\ *);;
		*) list="$list $i";;
		esac
	done
	ALL_DEPS="$ALL_DEPS$list "
	for i in $list; do
		[ -f $i/receipt ] || continue
		deps="$(DEPENDS=""; . $i/receipt; echo $DEPENDS)"
		case " $deps " in
		*\ $pkg\ *) echo -e "$MSG  $i"; MSG="";;
		*) check_for_deps_loop $pkg $deps;;
		esac
	done
}

# Check for missing deps listed in a receipt packages.
check_for_deps()
{
	local saved;
	saved=$PACKAGE
	mkdir -p $TMP_DIR
	( cd $TMP_DIR ; cpio -i receipt > /dev/null ) < $PACKAGE_FILE
	. $TMP_DIR/receipt
	PACKAGE=$saved
	rm -rf $TMP_DIR
	for pkgorg in $DEPENDS
	do
		i=$(equivalent_pkg $pkgorg $1)
		if [ ! -d "$1$INSTALLED/$i" ]; then
			MISSING_PACKAGE=$i
			deps=$(($deps+1))
		elif [ ! -f "$1$INSTALLED/$i/receipt" ]; then
			echo -e "$WARNING Dependency loop between $PACKAGE and $i."
		fi
	done
	if [ ! "$MISSING_PACKAGE" = "" ]; then
		echo -e "\033[1mTracking dependencies for :\033[0m $PACKAGE"
		echo "================================================================================"
		for pkgorg in $DEPENDS
		do
			i=$(equivalent_pkg $pkgorg $1)
			if [ ! -d "$1$INSTALLED/$i" ]; then
				MISSING_PACKAGE=$i
				echo "Missing : $MISSING_PACKAGE"
			fi
		done
		echo "================================================================================"
		echo "$deps missing package(s) to install."
	fi
}

# Install all missing deps. Auto install or ask user then install all missing 
# deps from local dir, cdrom, media or from the mirror. In case we want to
# install packages from local, we need a packages.list to find the version.
install_deps()
{
	local root
	root=""
	[ -n "$1" ] && root="--root=$1"
	if [ "$AUTO_INSTALL_DEPS" == "yes" ]; then
		anser="y"
	else
		echo ""
		echo -n "Install all missing dependencies (y/N) ? "; read anser
		echo ""
	fi
	if [ "$anser" == "y" ]; then
		for pkgorg in $DEPENDS
		do
			pkg=$(equivalent_pkg $pkgorg $1)
			if [ ! -d "$1$INSTALLED/$pkg" ]; then
				local list
				list="$INSTALL_LIST"
				[ -n "$list" ] || list="$TOP_DIR/packages.list"
				# We can install packages from a local dir by greping
				# the TAZPKG_BASENAME in the local packages.list.
				found=0
				if [ -f "$list" ]; then
					echo "Checking if $pkg exists in local list... "
					mkdir $TMP_DIR
					for i in $pkg-*.tazpkg; do
						[ -f $i ] || continue
						( cd $TMP_DIR ; cpio -i receipt > /dev/null) < $i
						[ "$(. $TMP_DIR/receipt; echo $PACKAGE)" = "$pkg" ] || continue
						if grep -q ^$(package_fullname_in_dir $TMP_DIR).tazpkg$ $list
						then
							found=1
							tazpkg install $i $root --list=$list
							break
						fi
					done
					rm -rf $TMP_DIR
				fi
				# Install deps from the mirror.
				if [ $found -eq 0 ]; then
					if [ ! -f "$LOCALSTATE/packages.list" ]; then
						tazpkg recharge
					fi
					tazpkg get-install $pkg $root
				fi
			fi
		done
	else
		echo -e "\nLeaving dependencies for $PACKAGE unsolved."
		echo -e "The package is installed but will probably not work.\n"
	fi
}

# xHTML packages list header.
xhtml_header()
{
	cat > $XHTML_LIST << _EOT_
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>Installed packages list</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
	<meta name="modified" content="$DATE" />
	<meta name="generator" content="Tazpkg" />
	<style type="text/css"><!--
	body { font: 12px sans-serif, vernada, arial; margin: 0; }
	#header { background: #f0ba08; color: black; height: 50px;
		border-top: 1px solid black; border-bottom: 1px solid black; }
	#content { margin: 0px 50px 26px 50px; }
	#footer { border-top: 1px solid black; padding-top: 10px;}
	h1 { margin: 14px 0px 0px 16px; }
	pre { padding-left: 5px; }
	hr { color: white; background: white; height: 1px; border: 0; }
	--></style>
</head>
<body bgcolor="#ffffff">
<div id="header">
<h1><font color="#3e1220">Installed packages list</font></h1>
</div>
<hr />
<!-- Start content -->
<div id="content">

<p>
_packages_ packages installed - List generated on : $DATE
<p>

_EOT_
}

# xHTML content with packages info.
xhtml_pkg_info()
{
	cat >> $XHTML_LIST << _EOT_
<h3>$PACKAGE</h3>
<pre>
Version    : $VERSION$EXTRAVERSION
Short desc : $SHORT_DESC
Web site   : <a href="$WEB_SITE">$WEB_SITE</a>
</pre>

_EOT_
}

# xHTML packages list footer.
xhtml_footer()
{
	cat >> $XHTML_LIST << _EOT_
<hr />
<p id="footer">
$packages packages installed - List generated on : $DATE
</p>

<!-- End content -->
</div>
</body>
</html>
_EOT_
}

# Search pattern in installed packages.
search_in_installed_packages()
{
	echo "Installed packages"
	echo "================================================================================"
	list=`ls -1 $INSTALLED | grep -i "$PATTERN"`
	for pkg in $list
	do
		EXTRAVERSION=""
		[ -f $INSTALLED/$pkg/receipt ] || continue
		. $INSTALLED/$pkg/receipt
		echo -n "$PACKAGE "
		echo -en "\033[24G $VERSION$EXTRAVERSION"
		echo -e "\033[42G $CATEGORY"
		packages=$(($packages+1))
	done
	# Set correct ending messages.
	if [ "$packages" = "" ]; then
		echo "0 installed packages found for : $PATTERN"
		echo ""
	else
		echo "================================================================================"
		echo "$packages installed package(s) found for : $PATTERN"
		echo ""
	fi
}

# Search in packages.list for available pkgs.
search_in_packages_list()
{
	echo "Available packages name-version"
	echo "================================================================================"
	packages=0
	for i in $LOCALSTATE/packages.list $LOCALSTATE/undigest/*/packages.list; do
		grep -is "$PATTERN" $i
		packages=$(($packages + `grep -is "$PATTERN" $i | wc -l`))
	done
	if [ ! -f "$LOCALSTATE/packages.list" ]; then
		echo -e "
No 'packages.list' found to check for mirrored packages. For more results,
please run 'tazpkg recharge' once as root before searching.\n"
	fi
	if [ "$packages" = "0" ]; then
		echo "0 available packages found for : $PATTERN"
		echo ""
	else
		echo "================================================================================"
		echo "$packages available package(s) found for : $PATTERN"
		echo ""
	fi
}

# search --mirror: Search in packages.txt for available pkgs and give more
# info than --list or default.
search_in_packages_txt()
{
	echo "Matching packages name with version and desc"
	echo "================================================================================"
	packages=0
	for i in $LOCALSTATE/packages.txt $LOCALSTATE/undigest/*/packages.txt; do
		grep -is -A 2 "^$PATTERN" $i
		packages=$(($packages + `grep -is "^$PATTERN" $i | wc -l`))
	done
	if [ ! -f "$LOCALSTATE/packages.txt" ]; then
		echo -e "
No 'packages.txt' found to check for mirrored packages. For more results,
please run 'tazpkg recharge' once as root before searching.\n"
	fi
	if [ "$packages" = "0" ]; then
		echo "0 available packages found for : $PATTERN"
		echo ""
	else
		echo "================================================================================"
		echo "$packages available package(s) found for : $PATTERN"
		echo ""
	fi
}

# Install package-list from a flavor
install_flavor()
{
	check_root
	FLAVOR=$1
	ARG=$2
	mkdir -p $TMP_DIR
	[ -f $FLAVOR.flavor ] && cp $FLAVOR.flavor $TMP_DIR
	cd $TMP_DIR
	if [ -f $FLAVOR.flavor ] || download $FLAVOR.flavor; then
		zcat $FLAVOR.flavor | cpio -i >/dev/null
		while read file; do
			for pkg in $(ls -d $INSTALLED/${file%%-*}*); do
				[ -f $pkg/receipt ] || continue
				EXTRAVERSION=""
				. $pkg/receipt
				[ "$PACKAGE-$VERSION$EXTRAVERSION" = "$file" ] && break
			done
			[ "$PACKAGE-$VERSION$EXTRAVERSION" = "$file" ] && continue
			cd $CACHE_DIR
			download $file.tazpkg
			cd $TMP_DIR
		        tazpkg install $CACHE_DIR/$file.tazpkg --forced
		done < $FLAVOR.pkglist
		[ -f $FLAVOR.nonfree ] && while read pkg; do
			[ -d $INSTALLED/$pkg ] || continue
			[ -d $INSTALLED/get-$pkg ] && tazpkg get-install get-$pkg
			get-$pkg
		done < $FLAVOR.nonfree
		[ "$ARG" == "--purge" ] && for pkg in $(ls $INSTALLED); do
			[ -f $INSTALLED/$pkg/receipt ] || continue
			EXTRAVERSION=""
			. $INSTALLED/$pkg/receipt
			grep -q ^$PACKAGE-$VERSION$EXTRAVERSION$ $FLAVOR.pkglist && continue
			grep -qs ^$PACKAGE$ $FLAVOR.nonfree && continue
			tazpkg remove $PACKAGE
		done
	else
		echo "Can't find flavor $FLAVOR. Aborting."
	fi
	cd $TOP_DIR
	rm -rf $TMP_DIR
}

# Update mirror urls
setup_mirror()
{
	# Backup old list.
	if [ -f "$1/mirror" ]; then
		cp -f $1/mirror $1/mirror.bak
	fi
	echo ""
	echo -e "\033[1mCurrent mirror(s)\033[0m"
	echo "================================================================================"
	echo "  `cat $1/mirror 2> /dev/null`"
	echo "
Please enter URL of the new mirror (http, ftp or local path). You must specify
the complete address to the directory of the packages and packages.list file."
	echo ""
	echo -n "New mirror(s) URL : "
	NEW_MIRROR_URL=$2
	if [ -n "$NEW_MIRROR_URL" ]; then
		echo $NEW_MIRROR_URL
	else
		read NEW_MIRROR_URL
	fi
	if [ "$NEW_MIRROR_URL" = "" ]; then
		echo "Nothing has been changed."
	else
		echo "Setting mirror(s) to : $NEW_MIRROR_URL"
		rm -f $1/mirror
		for i in $NEW_MIRROR_URL; do
			echo "$i" >> $1/mirror
		done
	fi
	echo ""
}

# recursive dependencies scan
dep_scan()
{
for i in $1; do
	case " $ALL_DEPS " in
	*\ $i\ *) continue;;
	esac
	ALL_DEPS="$ALL_DEPS $i"
	[ -n "$2" ] && echo "$2$i ($(grep -A 3 $i $LOCALSTATE/packages.txt \
				     | tail -1 | sed 's/.*(\([^ ]*\).*/\1/'))"
	[ -f $i/receipt ] || continue
	DEPENDS=""
	. $i/receipt
	[ -n "$DEPENDS" ] && dep_scan "$DEPENDS" "$2  "
done
}

# recursive reverse dependencies scan
rdep_scan()
{
SEARCH=$1

for i in * ; do
	DEPENDS=""
	. $i/receipt
	echo "$i $(echo $DEPENDS)"
done | awk -v search=$SEARCH '
function show_deps(deps, all_deps, pkg, space)
{
	if (all_deps[pkg] == 1) return
	all_deps[pkg] = 1
	if (space != "") printf "%s %s\n",space,pkg
	for (i = 1, n = split(deps[pkg], mydeps, " "); i <= n; i++) {
		show_deps(deps, all_deps, mydeps[i],"==" space)
	}
}

{
	all_deps[$1] = 0
	for (i = 2; i <= NF; i++)
		deps[$i] = deps[$i] " " $1
}

END {
	show_deps(deps, all_deps, search, "")
}
' | while read spc pkg; do
	echo -n $spc | sed 's/=/ /g'
	echo -n $pkg
	echo -n ' ('
	grep -A 3 $pkg $LOCALSTATE/packages.txt  | tail -1 | \
				    sed 's/.*(\([^ ]*\).*/\1)/'
done
}

# Check for ELF file
is_elf()
{
	[ "$(dd if=$1 bs=1 skip=1 count=3 2> /dev/null)" = "ELF" ]
}

# Print shared library dependencies
ldd()
{
	LD_TRACE_LOADED_OBJECTS=1 /lib/ld*.so $1 2> /dev/null
}

# search dependencies for files in $TMP_DIR/$file/fs
find_depends()
{
	DEFAULT_DEPENDS="glibc-base gcc-lib-base"

	[ -f /var/lib/tazpkg/files.list.lzma ] || tazpkg recharge > /dev/null
	for i in /var/lib/tazpkg/files.list.lzma \
 		/var/lib/tazpkg/undigest/*/files.list.lzma ; do
 		[ -f $i ] && lzma d $i -so >> $TMP_DIR/files.list
	done
	find $TMP_DIR/$file/fs -type f | while read chkfile ; do
		is_elf $chkfile || continue
		case "$chkfile" in
		*.o|*.ko|*.ko.gz) continue;;
		esac
		ldd $chkfile | while read lib rem; do
			case "$lib" in
			statically|linux-gate.so*|ld-*.so|*/ld-*.so)
				continue;;
			esac
			find $TMP_DIR/$file/fs | grep -q /$lib$ && continue
			for dep in $(grep $lib files.list | cut -d: -f1); do
				case " $DEFAULT_DEPENDS " in
				*\ $dep\ *) continue 2;;
				esac
				grep -qs "^$dep$" $TMP_DIR/depends && continue 2
			done
			if [ -n "$dep" ]; then
				echo "$dep" >> $TMP_DIR/depends
			else
				grep -qs ^$lib$ $TMP_DIR/unresolved ||
				echo "$lib" >> $TMP_DIR/unresolved
			fi
		done
	done
	spc=""
	cat $TMP_DIR/depends | sort | uniq | while read file; do
		echo -n "$spc$file"
		spc=" "
	done
}

show_unresolved_lib()
{
	if [ -s $TMP_DIR/unresolved ]; then
		echo "BUGS=\"No dependency for" >> $1
		cat $TMP_DIR/unresolved | sort | uniq | while read file; do
			echo -e "$WARNING: unknown dependency for $lib"
			echo -n " $file" >> $1
		done
		echo "\"" >> $1
	fi
}

# convert a .ipk package to .tazpkg
convert_ipk()
{
	mkdir -p $TMP_DIR
	tar xOzf $PACKAGE_FILE ./control.tar.gz | tar xzf - -C $TMP_DIR
	package="$(grep ^Package $TMP_DIR/control | sed 's/.*: //')"
	version="$(grep ^Version $TMP_DIR/control | sed 's/.*: //')"
	maintainer="$(grep ^Maintainer $TMP_DIR/control | sed 's/.*: //')"
	target="$(grep ^Architecture $TMP_DIR/control | sed 's/.*: //')"
	descrip="$(grep ^Description $TMP_DIR/control | sed 's/.*: //')"
	url="http://openwrt.org/"
	case "$target" in
	i386|all)
		file=$package-$version
		mkdir -p $TMP_DIR/$file/fs
		tar xOzf $PACKAGE_FILE ./data.tar.gz | \
			tar xzf - -C $TMP_DIR/$file/fs
		cd $TMP_DIR
		cat > $file/receipt <<EOT
# SliTaz package receipt.
# generated by tazpkg from package $(basename $PACKAGE_FILE)
PACKAGE="$package"
VERSION="$version"
CATEGORY="misc"
SHORT_DESC="$descrip"
WEB_SITE="$url"
MAINTAINER="$maintainer"
DEPENDS="$(find_depends)"
EOT
		[ -s conffiles ] && cat >> $file/receipt <<EOT
CONFIG_FILES="$(cat conffiles)"
EOT
		show_unresolved_lib $file/receipt
		while read script func; do
			[ -s $script ] && cat >> $file/receipt <<EOT

$func()
{
$(cat $script)
}
EOT
		done <<EOT
preinst		pre_install
postinst	post_install
prerm		pre_remove
postrm		post_remove
EOT
		awk '
{
   if (/^ / && show) print substr($0,2);
   else show=0;
   if (/^Description/) show=1;
}' < $TMP_DIR/control > $file/description.txt
		sed -i 's/^\.$//' $file/description.txt
		[ -s $file/description.txt ] || rm -f $file/description.txt
		tazpkg pack $file
		cd $TOP_DIR
		mv $TMP_DIR/$file.tazpkg .
		;;
	*)
		echo "Invalid target: $target (expected i386)"
		;;
	esac
	rm -rf $TMP_DIR
}

# convert a .pkg.tar.gz package to .tazpkg
convert_arch()
{
	mkdir -p $TMP_DIR/fs
	tar xzf $PACKAGE_FILE -C $TMP_DIR/fs
	if [ -f $TMP_DIR/fs/.PKGINFO ]; then
		cd $TMP_DIR
		package="$(grep ^pkgname fs/.PKGINFO | sed 's/.*= //')"
		version="$(grep ^pkgver  fs/.PKGINFO | sed 's/.*= //')"
		descrip="$(grep ^pkgdesc fs/.PKGINFO | sed 's/.*= //')"
		url="$(grep ^url fs/.PKGINFO | sed 's/.*= //')"
		maintainer="$(grep ^packager fs/.PKGINFO | sed 's/.*= //')"
		file=$package-$version
		mkdir $file
		mv fs $file
		cat > $file/receipt <<EOT
# SliTaz package receipt.
# generated by tazpkg from Archlinux package $(basename $PACKAGE_FILE)
PACKAGE="$package"
VERSION="$version"
CATEGORY="misc"
SHORT_DESC="$descrip"
WEB_SITE="$url"
MAINTAINER="$maintainer"
DEPENDS="$(find_depends)"
EOT
		show_unresolved_lib $file/receipt
		rm -f $file/fs/.[A-Z]*
		tazpkg pack $file
		mv $file.tazpkg $TOP_DIR
	else
		echo "$PACKAGE_FILE does not look like a Archlinux package !"
	fi
	cd $TOP_DIR
	rm -rf $TMP_DIR
}

# convert a .tgz package to .tazpkg
convert_tgz()
{
	package=$(basename $PACKAGE_FILE)
	IFS='-'
	set -- $package
	unset IFS
	package=$1
	version=$2
	file="$package-$version"
	mkdir -p $TMP_DIR/$file/fs
	tar xzf $PACKAGE_FILE -C $TMP_DIR/$file/fs
	cd $TMP_DIR
	if [ -d $file/fs/install ]; then
		descrip=$(grep ^$package $file/fs/install/slack-desc | \
			  head -1 | sed 's/.*(\(.*\)).*/\1/')
		cat > $file/receipt <<EOT
# SliTaz package receipt.
# generated by tazpkg from slackware package $(basename $PACKAGE_FILE)
PACKAGE="$package"
VERSION="$version"
CATEGORY="misc"
SHORT_DESC="$descrip"
WEB_SITE="http://www.slackware.com/packages/"
MAINTAINER="nobody@slitaz.org"
DEPENDS="$(find_depends)"
EOT
		show_unresolved_lib $file/receipt
		[ -f $file/fs/install/doinst.sh ] && cat >> $file/receipt <<EOM

post_install()
{
chroot \$1/ sh - << EOT
cd /
$(cat $file/fs/install/doinst.sh | sed -e 's/\\/\\\\/g' | sed -e 's/\$/\\$/g')
EOT
}
EOM
		grep ^$package $file/fs/install/slack-desc | \
			sed "s/^$package://" > $file/description.txt
		[ -s $file/description.txt ] || rm -f $file/description.txt
		rm -rf $file/fs/install
		tazpkg pack $file
		mv $file.tazpkg $TOP_DIR
	else
		echo "$PACKAGE_FILE does not look like a Slackware package !"
	fi
	cd $TOP_DIR
	rm -rf $TMP_DIR
}

# convert a .deb package to .tazpkg
convert_deb()
{
	mkdir -p $TMP_DIR
	dpkg-deb -e $PACKAGE_FILE $TMP_DIR
	package=$(grep '^ *Package' $TMP_DIR/control)
	package=$(echo ${package##*:})
	version=$(grep '^ *Version' $TMP_DIR/control)
	version=$(echo ${version##*:})
	descrip=$(grep '^ *Description' $TMP_DIR/control)
	descrip=$(echo ${descrip##*:})
	target="$(grep ^Architecture $TMP_DIR/control | sed 's/.*: //')"
	case "$target" in
	i386|all)
		file="$package-$version"
		mkdir -p $TMP_DIR/$file/fs/
		dpkg-deb -x $PACKAGE_FILE $TMP_DIR/$file/fs
		cd $TMP_DIR
		cat > $file/receipt <<EOT
# SliTaz package receipt.
# generated by tazpkg from debian package $(basename $PACKAGE_FILE)
PACKAGE="$package"
VERSION="$version"
CATEGORY="misc"
SHORT_DESC="$descrip"
WEB_SITE="http://packages.debian.org/search?keywords=$package"
MAINTAINER="nobody@slitaz.org"
DEPENDS="$(find_depends)"
EOT
		[ -s conffiles ] && cat >> $file/receipt <<EOT
CONFIG_FILES="$(cat conffiles)"
EOT
		show_unresolved_lib $file/receipt
		awk '
{
   if (/^ / && show) print substr($0,2);
   else show=0;
   if (/^Description/) show=1;
}' < $TMP_DIR/control > $file/description.txt
		sed -i 's/^\.$//' $file/description.txt
		[ -s $file/description.txt ] || rm -f $file/description.txt
		tazpkg pack $file
		mv $file.tazpkg $TOP_DIR
		;;
	*)
		echo "Invalid target: $target (expected i386)"
		;;
	esac
	cd $TOP_DIR
	rm -rf $TMP_DIR
}

# convert a .rpm package to .tazpkg
convert_rpm()
{
	mkdir -p $TMP_DIR
	cp $PACKAGE_FILE $TMP_DIR
	PACKAGE_FILE=$TMP_DIR/$(basename $PACKAGE_FILE)
	rpm -qip $PACKAGE_FILE | awk -v pkg=$(basename $PACKAGE_FILE) '
BEGIN {
	goturl=0;
	printf "# Taz package receipt.\n";
	printf "# generated by tazpkg from rpm package %s\n",pkg;
}
{
	if (/^Name/) { name=$3; printf "PACKAGE=\"%s\"\n",$3; }
	if (/^Version/) printf "VERSION=\"%s-",$3;
	if (/^Release/) printf "%s\"\n",$3;
	if (/^Summary/) printf "SHORT_DESC=\"%s\"\n",substr($0,15);
	if (/^URL/) { goturl=1; printf "WEB_SITE=\"%s\"\n",$3; }
}
END {
	if (goturl == 0)
		printf "WEB_SITE=\"http://rpmfind.net/linux/rpm2html/search.php?query=%s\"\n",name;
	printf "CATEGORY=\"misc\"\n";
	printf "MAINTAINER=\"nobody@slitaz.org\"\n";
}
' > $TMP_DIR/receipt
	. $TMP_DIR/receipt
	file=$PACKAGE-$VERSION
	mkdir -p $TMP_DIR/$file/fs/
	mv $TMP_DIR/receipt $TMP_DIR/$file
	rpm -qip $PACKAGE_FILE | awk '
DEGIN { show=0 }
{
  if (show) print;
  if (/^Description/) show=1;
}
' > $TMP_DIR/$file/description.txt
	cd $TMP_DIR/$file/fs/
	rpm2cpio $PACKAGE_FILE | cpio -idm
	cd ../..
	echo "DEPENDS=\"$(find_depends)\"" >> $TMP_DIR/$file/receipt
	show_unresolved_lib $TMP_DIR/$file/receipt
	tazpkg pack $file
	mv $file.tazpkg $TOP_DIR
	cd $TOP_DIR
	rm -rf $TMP_DIR
}

###################
# Tazpkg commands #
###################

case "$COMMAND" in
	list)
		# List all installed packages or a specific category.
		#
		if [ "$2" = "blocked" ]; then
			echo ""
			echo -e "\033[1mBlocked packages\033[0m"
			echo "================================================================================"
			if [ -s "$BLOCKED" ];then
				cat $BLOCKED
				echo ""
			else
				echo -e "No blocked packages found.\n"
			fi
			exit 0
		fi
		# Display the list of categories.
		if [ "$2" = "cat" -o "$2" = "categories" ]; then
			echo ""
			echo -e "\033[1mPackages categories :\033[0m"
			echo "================================================================================"
			for i in $CATEGORIES
			do
				echo $i
				categories=$(($categories+1))
			done
			echo "================================================================================"
			echo "$categories categories"
			echo ""
			exit 0
		fi
		# Check for an asked category.
		if [ -n "$2" ]; then
			ASKED_CATEGORY=$2
			echo ""
			echo -e "\033[1mInstalled packages of category :\033[0m $ASKED_CATEGORY"
			echo "================================================================================"
			for pkg in $INSTALLED/*
			do
				[ -f $pkg/receipt ] || continue
				EXTRAVERSION=""
				. $pkg/receipt
				if [ "$CATEGORY" == "$ASKED_CATEGORY" ]; then
					echo -n "$PACKAGE"
					echo -e "\033[24G $VERSION$EXTRAVERSION"
					packages=$(($packages+1))
				fi
			done
			echo "================================================================================"
			echo -e "$packages packages installed of category $ASKED_CATEGORY."
			echo ""
		else
			# By default list all packages and versions.
			echo ""
			echo -e "\033[1mList of all installed packages\033[0m"
			echo "================================================================================"
			for pkg in $INSTALLED/*
			do
				[ -f $pkg/receipt ] || continue
				EXTRAVERSION=""
				. $pkg/receipt
				echo -n "$PACKAGE"
				echo -en "\033[24G $VERSION$EXTRAVERSION"
				echo -e "\033[42G $CATEGORY"
				packages=$(($packages+1))
			done
			echo "================================================================================"
			echo "$packages packages installed."
			echo ""
		fi ;;
	xhtml-list)
		# Get info in receipts and build list.
		DATE=`date +%Y-%m-%d\ \%H:%M:%S`
		if [ -n "$2" ]; then
			XHTML_LIST=$2
		else
			XHTML_LIST=installed-packages.html
		fi
		echo ""
		echo -e "\033[1mCreating xHTML list of installed packages\033[0m"
		echo "================================================================================"
		echo -n "Generating xHTML header..."
		xhtml_header
		status
		# Packages
		echo -n "Creating packages information..."
		for pkg in $INSTALLED/*
		do
			[ -f $pkg/receipt ] || continue
			EXTRAVERSION=""
			. $pkg/receipt
			xhtml_pkg_info
			packages=$(($packages+1))
		done
		status
		echo -n "Generating xHTML footer..."
		xhtml_footer
		status
		# sed pkgs nb in header.
		sed -i s/'_packages_'/"$packages"/ $XHTML_LIST
		echo "================================================================================"
		echo "$XHTML_LIST created - $packages packages."
		echo "" ;;
	list-mirror)
		# List all available packages on the mirror. Option --diff displays
		# last mirrored packages diff (see recharge).
		check_for_packages_list
		case $2 in
			--diff)
				if [ -f "$LOCALSTATE/packages.diff" ]; then
					echo ""
					echo -e "\033[1mMirrored packages diff\033[0m"
					echo "================================================================================"
					cat $LOCALSTATE/packages.diff
					echo "================================================================================"
					pkgs=`cat $LOCALSTATE/packages.diff | wc -l`
					echo "$pkgs new packages listed on the mirror."
					echo ""
				else
					 echo -e "\nUnable to list anything, no packages.diff found."
					 echo -e "Recharge your current list to create a first diff.\n"
				fi && exit 0 ;;
			--text|--txt)
				echo ""
				echo -e "\033[1mList of available packages on the mirror\033[0m"
				echo "================================================================================"
				cat $LOCALSTATE/packages.txt ;;
			--raw|*)
				echo ""
				echo -e "\033[1mList of available packages on the mirror\033[0m"
				echo "================================================================================"
				cat $LOCALSTATE/packages.list ;;
		esac
		echo "================================================================================"
		pkgs=`cat $LOCALSTATE/packages.list | wc -l`
		echo "$pkgs packages in the last recharged list."
		echo "" ;;
	list-files)
		# List files installed with the package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		echo ""
		echo -e "\033[1mInstalled files with :\033[0m $PACKAGE"
		echo "================================================================================"
		cat $INSTALLED/$PACKAGE/files.list | sort
		echo "================================================================================"
		files=`cat $INSTALLED/$PACKAGE/files.list | wc -l`
		echo "$files files installed with $PACKAGE."
		echo "" ;;
	info)
		# Information about package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		EXTRAVERSION=""
		. $INSTALLED/$PACKAGE/receipt
		echo ""
		echo -e "\033[1mTazpkg information\033[0m
================================================================================
Package    : $PACKAGE
Version    : $VERSION$EXTRAVERSION
Category   : $CATEGORY
Short desc : $SHORT_DESC
Maintainer : $MAINTAINER"
		if [ ! "$DEPENDS" = "" ]; then
			echo -e "Depends    : $DEPENDS"
		fi
		if [ ! "$SUGGESTED" = "" ]; then
			echo -e "Suggested  : $SUGGESTED"
		fi
		if [ ! "$BUILD_DEPENDS" = "" ]; then
			echo -e "Build deps : $BUILD_DEPENDS"
		fi
		if [ ! "$WANTED" = "" ]; then
			echo -e "Wanted src : $WANTED"
		fi
		if [ ! "$WEB_SITE" = "" ]; then
			echo -e "Web site   : $WEB_SITE"
		fi
		echo "================================================================================"
		echo "" ;;
	desc)
		# Display package description.txt if available.
		if [ -f "$INSTALLED/$PACKAGE/description.txt" ]; then
			echo ""
			echo -e "\033[1mDescription of :\033[0m $PACKAGE"
			echo "================================================================================"
			cat $INSTALLED/$PACKAGE/description.txt
			echo "================================================================================"
			echo ""
		else
			echo -e "\nSorry, no description available for this package.\n"
		fi ;;
	search)
		# Search for a package by pattern or name.
		#
		PATTERN="$2"
		if [ -z "$PATTERN" ]; then
			echo -e "\nPlease specify a pattern or package name to search for."
			echo -e "Example : 'tazpkg search paint'.\n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mSearch result for :\033[0m $PATTERN"
		echo ""
		# Default is to search in installed pkgs and the raw list.
		case $3 in
			-i|--installed)
				search_in_installed_packages ;;
			-l|--list)
				search_in_packages_list ;;
			-m|--mirror)
				search_in_packages_txt ;;
			*)
				search_in_installed_packages
				search_in_packages_list ;;
		esac ;;
	search-file)
		# Search for a file by pattern or name in all files.list.
		#
		if [ -z "$2" ]; then
			echo -e "\nPlease specify a pattern or file name to search for."
			echo -e "Example : 'tazpkg search-file libnss'. \n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mSearch result for file :\033[0m $2"
		echo "================================================================================"

		if [ "$3" == "--mirror" ]; then

			match=0
			for i in $LOCALSTATE/files.list.lzma \
				 $LOCALSTATE/undigest/*/files.list.lzma; do
				 [ -f $i ] || continue
				unlzma -c $i | grep -- ".*:.*$2" | awk '
                            BEGIN { last="" }
                            {
			    	pkg=substr($0,0,index($0,":")-1);
			    	file=substr($0,index($0,":")+2);
                                if (last != pkg) {
				    last = pkg;
				    printf("\n%c[1mPackage %s :%c[0m\n",27,pkg,27);
				}
                                printf("%s\n",file);
                            }'
				match=$(($match + `unlzma -c $i | grep -- ".*:.*$2" | wc -l`))
			done

		else

		# Check all pkg files.list in search match with specify the package
		# name and the full path to the file(s).
		for pkg in $INSTALLED/*
		do
			if grep -qs "$2" $pkg/files.list; then
				. $pkg/receipt
				echo ""
				echo -e "\033[1mPackage $PACKAGE :\033[0m"
				grep "$2" $pkg/files.list
				files=`grep $2 $pkg/files.list | wc -l`
				match=$(($match+$files))
			fi
		done

		fi

		if [ "$match" = "" ]; then
			echo "0 file found for : $2"
			echo ""
		else
			echo ""
			echo "================================================================================"
			echo "$match file(s) found for : $2"
			echo ""
		fi ;;
	search-pkgname) 
		#
		if [ -z "$2" ]; then
			echo -e "\nPlease specify a pattern or file name to search for."
			echo -e "Example : 'tazpkg search-pkgname libnss'. \n"
			exit 0
		fi
		echo ""
		echo -e "\033[1mSearch result for file :\033[0m $2"
		echo "================================================================================"
       
	 # Search for a file on mirror and output only the package name
		match=0
		for i in $LOCALSTATE/files.list.lzma \
				 $LOCALSTATE/undigest/*/files.list.lzma; do
				 [ -f $i ] || continue
				unlzma -c $i | grep -- ".*:.*$2" | cut -d: -f1 | uniq | awk '{ print $1 }'
				match=$(($match + `unlzma -c $i | grep -- ".*:.*$2" | cut -d: -f1 | uniq | wc -l`))
		done
			
		if [ "$match" = "" ]; then
			echo "0 file found for : $2"
			echo ""
		else
			echo ""
			echo "================================================================================"
			echo "$match pkg(s) found with file : $2"
			echo ""
		fi
		;;
	install)
		# Install .tazpkg packages.
		#
		check_root
		check_for_package_on_cmdline
		check_for_package_file
		# Check if forced install.
		DO_CHECK="yes"
		ROOT=""
		while [ -n "$3" ]; do
			case "$3" in
			--forced)
				DO_CHECK="no"
				;;
			--root=*)
				ROOT="${3#--root=}"
				;;
			--list=*)
				INSTALL_LIST="${3#--list=}"
				;;
			*)	shift 2
				echo -e "\nUnknown option $*.\n"
				exit 1
				;;
			esac
			shift
		done
		if [ "$DO_CHECK" = "yes" ]; then
			check_for_installed_package $ROOT
		fi
		AUTO_INSTALL_DEPS="no"
		install_package $ROOT ;;
	install-list|get-install-list)
		# Install a set of packages from a list.
		#
		check_root
		if [ -z "$2" ]; then
			echo -e "
Please change directory (cd) to the packages repository, and specify the
list of packages to install. Example : tazpkg install-list packages.list\n"
			exit 0
		fi
		# Check if the packages list exist.
		if [ ! -f "$2" ]; then
			echo "Unable to find : $2"
			exit 0
		else
			LIST=`cat $2`
		fi

		# Remember processed list
		export INSTALL_LIST="$2"

		# Set $COMMAND and install all packages.
		if [ "$1" = "get-install-list" ]; then
			COMMAND=get-install
		else
			COMMAND=install
		fi
		touch $2-processed

		# Upgrade tazpkg first. It may handle new features/formats...
		case " $LIST " in
		*\ tazpkg\ *) LIST="tazpkg $LIST";;
		esac

		for pkg in $LIST
		do
			grep -qs ^$pkg$ $2-processed && continue
			tazpkg $COMMAND $pkg --list=$2 "$3" "$4" "$5"
		done
		rm -f $2-processed ;;
	add-flavor)
		# Install a set of packages from a flavor.
		#
		install_flavor $2 ;;
	install-flavor)
		# Install a set of packages from a flavor and purge other ones.
		#
		install_flavor $2 --purge ;;
	set-release)
		# Change curent release and upgrade packages.
		#
		RELEASE=$2
		if [ -z "$RELEASE" ]; then
			echo -e "\nPlease specify the release you want on the command line."
			echo -e "Example: tazpkg set-release cooking\n"
			exit 0
		fi
		rm /var/lib/tazpkg/mirror
		echo "$RELEASE" > ${LOCALSTATE}/slitaz-release
		tazpkg recharge && tazpkg upgrade

		# Install missing depends
		cd $INSTALLED
		for i in * ; do
			DEPENDS=""
			. $i/receipt
			for j in $DEPENDS ; do
				[ -d $j ] || tazpkg get-install $j
			done
		done ;;
	remove)
		# Remove packages.
		#
		check_root
		check_for_package_on_cmdline
		if [ ! -f "$INSTALLED/$PACKAGE/receipt" ]; then
			echo -e "\n$PACKAGE is not installed.\n"
			exit 0
		else
			ALTERED=""
			THE_PACKAGE=$PACKAGE	# altered by receipt
			for i in $(cd $INSTALLED ; ls); do
				[ -f $INSTALLED/$i/receipt ] || continue
				DEPENDS=""
				. $INSTALLED/$i/receipt
				case " $(echo $DEPENDS) " in
				*\ $THE_PACKAGE\ *) ALTERED="$ALTERED $i";;
				esac
			done
			EXTRAVERSION=""
			. $INSTALLED/$THE_PACKAGE/receipt
		fi
		echo ""
		if [ -n "$ALTERED" ]; then
			echo "The following packages depend on $PACKAGE :"
			for i in $ALTERED; do
				echo "  $i"
			done
		fi
		REFRESH=$(cd $INSTALLED ; grep -sl ^$PACKAGE$ */modifiers)
		if [ -n "$REFRESH" ]; then
			echo "The following packages have been modified by $PACKAGE :"
			for i in $REFRESH; do
				echo "  ${i%/modifiers}"
			done
		fi
		echo "Remove $PACKAGE ($VERSION$EXTRAVERSION) ?"
		echo -n "Please confirm uninstallation (y/N) : "; read anser
		if [ "$anser" = "y" ]; then
			echo ""
			echo -e "\033[1mRemoving :\033[0m $PACKAGE"
			echo "================================================================================"
			# Pre remove commands.
			if grep -q ^pre_remove $INSTALLED/$PACKAGE/receipt; then
				pre_remove
			fi
			echo -n "Removing all files installed..."
			if [ -f $INSTALLED/$PACKAGE/modifiers ]; then
			    for mod in `cat $INSTALLED/$PACKAGE/modifiers`
			    do
				for file in `cat $INSTALLED/$PACKAGE/files.list`
				do
					[ $(grep ^$file$ $INSTALLED/$mod/files.list | wc -l) -gt 1 ] && continue
					remove_with_path $file
				done
			    done
			else
				for file in `cat $INSTALLED/$PACKAGE/files.list`
				do
					remove_with_path $file
				done
			fi
			status
			if grep -q ^post_remove $INSTALLED/$PACKAGE/receipt; then
				post_remove
			fi
			# Remove package receipt.
			echo -n "Removing package receipt..."
			rm -rf $INSTALLED/$PACKAGE
			status
			sed -i "/ $PACKAGE-$VERSION$EXTRAVERSION$/d" \
				$LOCALSTATE/installed.md5 2> /dev/null
			# Log this activity
			log Removed
			if [ -n "$ALTERED" ]; then
				echo -n "Remove packages depending on $PACKAGE"
				echo -n " (y/N) ? "; read anser
				if [ "$anser" = "y" ]; then
					for i in $ALTERED; do
						if [ -d "$INSTALLED/$i" ]; then
							tazpkg remove $i
						fi
					done
				fi
			fi
			if [ -n "$REFRESH" ]; then
				echo -n "Reinstall packages modified by $PACKAGE"
				echo -n " (y/N) ? "; read anser
				if [ "$anser" = "y" ]; then
					for i in $REFRESH; do
						if [ $(wc -l < $INSTALLED/$i) -gt 1 ]; then
							echo "Check $INSTALLED/$i for reinstallation"
							continue
						fi
						rm -r $INSTALLED/$i
						tazpkg get-install ${i%/modifiers} --forced
					done
				fi
			fi
		else
			echo ""
			echo "Uninstallation of $PACKAGE cancelled."
		fi
		echo "" ;;
	extract)
		# Extract .tazpkg cpio archive into a directory.
		#
		check_for_package_on_cmdline
		check_for_package_file
		echo ""
		echo -e "\033[1mExtracting :\033[0m $PACKAGE"
		echo "================================================================================"
		# If no directory destination is found on the cmdline
		# we create one in the current dir using the package name.
		if [ -n "$TARGET_DIR" ]; then
			DESTDIR=$TARGET_DIR/$PACKAGE
		else
			DESTDIR=$PACKAGE
		fi
		mkdir -p $DESTDIR
		echo -n "Copying original package..."
		cp $PACKAGE_FILE $DESTDIR
		status
		cd $DESTDIR
		extract_package
		echo "================================================================================"
		echo "$PACKAGE is extracted to : $DESTDIR"
		echo "" ;;
	recompress)
		# Recompress .tazpkg cpio archive with lzma.
		#
		check_for_package_on_cmdline
		check_for_package_file
		echo ""
		echo -e "\033[1mRecompressing :\033[0m $PACKAGE"
		echo "================================================================================"
		mkdir -p $TMP_DIR
		echo -n "Copying original package..."
		cp $PACKAGE_FILE $TMP_DIR
		status
		cd $TMP_DIR
		extract_package
		echo -n "Recompressing the fs... "
		find fs | cpio -o -H newc 2> /dev/null | lzma e fs.cpio.lzma -si
		rm -rf fs
		status
		echo -n "Creating new package... "
		find . -print | cpio -o -H newc > \
			$TOP_DIR/$(basename $PACKAGE_FILE).$$ && mv -f \
			$TOP_DIR/$(basename $PACKAGE_FILE).$$ \
			$TOP_DIR/$(basename $PACKAGE_FILE)
		status
		cd $TOP_DIR
		rm -rf $TMP_DIR ;;
	list-config)
		# List configuration files installed.
		#
		if [ "$2" = "--box" ]; then
			mkdir -p $TMP_DIR && cd $TMP_DIR
			FILES="$INSTALLED/*/volatile.cpio.gz"
			[ -n "$3" ] && FILES="$INSTALLED/$3/volatile.cpio.gz"
			for i in $FILES; do
				zcat $i | cpio -idm > /dev/null
				find * -type f 2>/dev/null | while read file; do
					if [ ! -e /$file ]; then
					echo -n "|--|--|--|File lost"
					else
					echo -n "$(stat -c "%A|%U|%G|%s|" /$file)"
					cmp $file /$file > /dev/null 2>&1 || \
						echo -n "$(stat -c "%.16y" /$file)"
					fi
					echo "|/$file"
				done
				rm -rf *
			done
			cd $TOP_DIR
			rm -rf $TMP_DIR
		else
			echo ""
			echo -e "\033[1mConfiguration files"
			echo "================================================================================"
			for i in $INSTALLED/*/volatile.cpio.gz; do
				[ -n "$2" -a "$i" != "$INSTALLED/$2/volatile.cpio.gz" ] && continue
				[ -f "$i" ] || continue
				zcat $i | cpio -t | grep -v "[0-9]* blocks"
			done | sed 's|^|/|' | sort
			echo "================================================================================"
			echo ""
		fi ;;
	repack-config)
		# Create SliTaz package archive from configuration files.
		#
		mkdir -p $TMP_DIR && cd $TMP_DIR
		CONFIG_VERSION=1.0
		mkdir config-$CONFIG_VERSION
		cd config-$CONFIG_VERSION
		for i in $INSTALLED/*/volatile.cpio.gz; do
			zcat $i | cpio -t | grep -v "[0-9]* blocks"
		done > files.list
		mkdir fs
		cd fs
		( cd / ; cpio -o -H newc ) < ../files.list | cpio -idm > /dev/null
		mkdir -p etc/tazlito
		for i in $INSTALLED/*/receipt; do
			EXTRAVERSION=""
			. $i
			echo "$PACKAGE-$VERSION$EXTRAVERSION"
		done > etc/tazlito/config-packages.list
		cd ..
		echo "etc/tazlito/config-packages.list" >> files.list
		cat > receipt <<EOT
# SliTaz package receipt.

PACKAGE="config"
VERSION="$CONFIG_VERSION"
CATEGORY="base-system"
SHORT_DESC="User configuration backup on $(date)"
DEPENDS="$(ls $INSTALLED)"
EOT
		cd ..
		tazpkg pack config-$CONFIG_VERSION
		cp config-$CONFIG_VERSION.tazpkg $TOP_DIR
		cd $TOP_DIR
		rm -rf $TMP_DIR
		;;
	repack)
		# Create SliTaz package archive from an installed package.
		#
		check_for_package_on_cmdline
		check_for_receipt
		EXTRAVERSION=""
		. $INSTALLED/$PACKAGE/receipt
		echo ""
		echo -e "\033[1mRepacking :\033[0m $PACKAGE-$VERSION$EXTRAVERSION.tazpkg"
		echo "================================================================================"
		if grep -qs ^NO_REPACK= $INSTALLED/$PACKAGE/receipt; then
			echo "Can't repack $PACKAGE"
			exit 1
		fi
		if [ -s $INSTALLED/$PACKAGE/modifiers ]; then
			echo "Can't repack, $PACKAGE files have been modified by:"
			for i in $(cat $INSTALLED/$PACKAGE/modifiers); do
				echo "  $i"
			done
			exit 1
		fi
		MISSING=""
		while read i; do
			[ -e "$i" ] && continue
			[ -L "$i" ] || MISSING="$MISSING\n  $i"
		done < $INSTALLED/$PACKAGE/files.list
		if [ -n "$MISSING" ]; then
			echo -n "Can't repack, the following files are lost:"
			echo -e "$MISSING"
			exit 1
		fi
		mkdir -p $TMP_DIR && cd $TMP_DIR
		FILES="fs.cpio.lzma\n"
		for i in $(ls $INSTALLED/$PACKAGE) ; do
			[ "$i" = "volatile.cpio.gz" ] && continue
			[ "$i" = "modifiers" ] && continue
			cp $INSTALLED/$PACKAGE/$i . && FILES="$FILES$i\n"
		done
		ln -s / rootfs
		mkdir tmp
		sed 's/^/rootfs/' < files.list | cpio -o -H newc 2>/dev/null |\
		      ( cd tmp ; cpio -idm >/dev/null )
		mv tmp/rootfs fs
		if [ -f $INSTALLED/$PACKAGE/volatile.cpio.gz ]; then
			zcat $INSTALLED/$PACKAGE/volatile.cpio.gz | \
				( cd fs; cpio -idm )
		fi
		if grep -q repack_cleanup $INSTALLED/$PACKAGE/receipt; then
			. $INSTALLED/$PACKAGE/receipt
			repack_cleanup fs
		fi
		if [ -f $INSTALLED/$PACKAGE/md5sum ]; then
			sed 's,  ,  fs,' < $INSTALLED/$PACKAGE/md5sum | \
			md5sum -s -c || {
				echo "Can't repack, md5sum error."
				cd $TOP_DIR
				rm -rf $TMP_DIR
				exit 1
			}
		fi
		find fs | cpio -o -H newc 2> /dev/null | lzma e fs.cpio.lzma -si
		echo -e "$FILES" | cpio -o -H newc 2> /dev/null > \
			$TOP_DIR/$PACKAGE-$VERSION$EXTRAVERSION.tazpkg
		cd $TOP_DIR
		\rm -R $TMP_DIR
		echo "Package $PACKAGE repacked successfully."
		echo "Size : `du -sh $PACKAGE-$VERSION$EXTRAVERSION.tazpkg`"
		echo "" ;;
	pack)
		# Create SliTaz package archive using cpio and gzip.
		#
		check_for_package_on_cmdline
		cd $PACKAGE
		if [ ! -f "receipt" ]; then
			echo "Receipt is missing. Please read the documentation."
			exit 0
		else
			echo ""
			echo -e "\033[1mPacking :\033[0m $PACKAGE"
			echo "================================================================================"
			# Create files.list with redirecting find outpout.
			echo -n "Creating the list of files..." && cd fs
			find . -type f -print > ../files.list
			find . -type l -print >> ../files.list
			cd .. && sed -i s/'^.'/''/ files.list
			status
			echo -n "Creating md5sum of files..."
			while read file; do
				[ -L "fs$file" ] && continue
				[ -f "fs$file" ] || continue
				case "$file" in
				/lib/modules/*/modules.*|*.pyc) continue;;
				esac
				md5sum "fs$file" | sed 's/  fs/  /'
			done < files.list > md5sum
			status
			UNPACKED_SIZE=$(du -chs fs receipt files.list md5sum \
				description.txt 2> /dev/null | awk \
				'{ sz=$1 } END { print sz }')
			# Build cpio archives.
			echo -n "Compressing the fs... "
			find fs | cpio -o -H newc | lzma e fs.cpio.lzma -si
			rm -rf fs
			status
			PACKED_SIZE=$(du -chs fs.cpio.lzma receipt files.list \
				md5sum description.txt 2> /dev/null | awk \
				'{ sz=$1 } END { print sz }')
			echo -n "Undating receipt sizes..."
			sed -i s/^PACKED_SIZE.*$// receipt
			sed -i s/^UNPACKED_SIZE.*$// receipt
			sed -i "s/^PACKAGE=/PACKED_SIZE=\"$PACKED_SIZE\"\nUNPACKED_SIZE=\"$UNPACKED_SIZE\"\nPACKAGE=/" receipt
			status
			echo -n "Creating full cpio archive... "
			find . -print | cpio -o -H newc > ../$PACKAGE.tazpkg
			status
			echo -n "Restoring original package tree... "
			unlzma -c fs.cpio.lzma | cpio -idm
			status
			rm fs.cpio.lzma && cd ..
			echo "================================================================================"
			echo "Package $PACKAGE compressed successfully."
			echo "Size : `du -sh $PACKAGE.tazpkg`"
			echo ""
		fi ;;
	recharge)
		# Recharge packages.list from a mirror.
		#
		check_root
		for path in $LOCALSTATE $LOCALSTATE/undigest/*; do
			[ -f $path/mirror ] || continue
			echo ""
			if [ "$path" != "$LOCALSTATE" ]; then
				echo "Recharge undigest $(basename $path):"
			fi
			cd $path
			if [ -f "packages.list" ]; then
				echo -n "Creating backup of the last packages list..."
				mv -f packages.desc packages.desc.bak 2>/dev/null
				mv -f packages.md5 packages.md5.txt 2>/dev/null
				mv -f packages.txt packages.txt.bak 2>/dev/null
				mv -f packages.list packages.list.bak 2>/dev/null
				mv -f packages.equiv packages.equiv.bak 2>/dev/null
				mv -f files.list.lzma files.list.lzma.bak 2> /dev/null
				mv -f mirrors mirrors.bak 2> /dev/null
				status
			fi
			download_from "$(cat mirror)" packages.desc
			download_from "$(cat mirror)" packages.md5
			download_from "$(cat mirror)" packages.txt
			download_from "$(cat mirror)" packages.list
			download_from "$(cat mirror)" packages.equiv
			download_from "$(cat mirror)" files.list.lzma
			download_from "$(sed 's|packages/.*||' < mirror)" mirrors
			[ -f mirrors ] || mv mirrors.bak mirrors 2> /dev/null
			suffix=$(head -1 mirror)
			suffix=packages${suffix#*/packages}
			for i in $(cat mirrors 2> /dev/null); do
				grep -qs $i mirror || echo $i$suffix >> mirror
			done
			if [ -f "packages.list.bak" ]; then
				diff -u packages.list.bak packages.list | grep ^+[a-z] > packages.diff
				sed -i s/+// packages.diff
				echo ""
				echo -e "\033[1mMirrored packages diff\033[0m"
				echo "================================================================================"
				cat packages.diff
				if [ ! "`cat packages.diff | wc -l`" = 0 ]; then
					echo "================================================================================"
					echo "`cat packages.diff | wc -l` new packages on the mirror."
					echo ""
				else
					echo "`cat packages.diff | wc -l` new packages on the mirror."
					echo ""
				fi
			else
				echo -e "
================================================================================
Last packages.list is ready to use. Note that next time you recharge the list,
a list of differences will be displayed to show new and upgradeable packages.\n"
			fi
		done ;;
	upgradeable)
		# Build upgradeable-packages.list quickly.
		#
		check_root
		cd $LOCALSTATE
		while read md5 file ; do
			grep -qs "$md5  $file" packages.md5 && continue
			for i in 1 2 3 4 5; do
				file=${file%-*}
				[ -d installed/$file ] || continue
				echo $file
				break
			done
		done < installed.md5 > upgradeable-packages.list ;;
	upgrade)
		# Upgrade all installed packages with the new version from the mirror.
		#
		check_root
		check_for_packages_list
		cd $LOCALSTATE
		# Touch the blocked pkgs list to avoid errors and remove any old
		# upgrade list.
		touch blocked-packages.list
		rm -f upgradeable-packages.list
		echo ""
		echo -e "\033[1mAvailable upgrades\033[0m"
		echo "================================================================================"
		echo ""
		# Some packages must be installed first
		FIRST_CLASS_PACKAGE=" glibc-base slitaz-base-files slitaz-boot-scripts "
		if [ -n "$PACKAGE_FILE" -a -d "$INSTALLED/$PACKAGE_FILE" ]; then
			ALL=$INSTALLED/$PACKAGE_FILE
		else
			ALL="$(ls -d $INSTALLED/*)"
		fi
		for pkg in $ALL
		do
			[ -f $pkg/receipt ] || continue
			EXTRAVERSION=""
			. $pkg/receipt
			# Display package name to show that Tazpkg is working...
			echo -en "\\033[0G                                         "
			echo -en "\\033[0G$PACKAGE"
			# Skip specified pkgs listed in $LOCALSTATE/blocked-packages.list
			if grep -qs "^$PACKAGE" $BLOCKED; then
				blocked=$(($blocked+1))
			else
				# Check if the installed package is in the current list (other
				# mirror or local).
				NEW_PACKAGE=$(get_package_filename $PACKAGE)

				if [ -n "$NEW_PACKAGE" ]; then
					# Set new pkg and version for future comparison
					NEW_VERSION=`echo $NEW_PACKAGE | sed s/$PACKAGE-/''/`
					# Change '-' and 'pre' to points.
					NEW_VERSION=`echo $NEW_VERSION | sed s/'-'/'.'/`
					VERSION=`echo $VERSION | sed s/'-'/'.'/`$EXTRAVERSION
					NEW_VERSION=`echo $NEW_VERSION | sed s/'pre'/'.'/`
					VERSION=`echo $VERSION | sed s/'pre'/'.'/`
					NEW_VERSION=`echo $NEW_VERSION | sed 's/[A-Z]\.//'`
					VERSION=`echo $VERSION | sed 's/[A-Z]\.//'`
					# Compare version. Upgrades are only available for official
					# packages, so we control the mirror and it should be ok if
					# we just check for equality.
					RELEASE=""
					if [ -f installed.md5 -a -f packages.md5 ]; then
						current_md5=$(grep -s "  $PACKAGE-$VERSION" installed.md5 | awk '{ print $1 }')
						new_md5=$(grep -hs "  $PACKAGE-$VERSION" packages.md5 undigest/*/packages.md5 | head -1 | awk '{ print $1 }')
						[ -n "$current_md5" ] && [ -n "$new_md5" ] &&
						[ "$current_md5" != "$new_md5" ] && RELEASE=build
					fi
					if [ "$VERSION" != "$NEW_VERSION" -o -n "$RELEASE" ]; then
						# Version seems different. Check for major, minor or
						# revision
						PKG_MAJOR=`echo ${VERSION%_*} | cut -f1 -d"."`
						NEW_MAJOR=`echo ${NEW_VERSION%_*} | cut -f1 -d"."`
						PKG_MINOR=`echo ${VERSION%_*} | cut -f2 -d"."`
						NEW_MINOR=`echo ${NEW_VERSION%_*} | cut -f2 -d"."`
						# Minor
						if [ "$NEW_MINOR" -gt "$PKG_MINOR" ] 2> /dev/null; then
							RELEASE=minor
						fi
						if [ "$NEW_MINOR" -lt "$PKG_MINOR" ] 2> /dev/null; then
							RELEASE=$WARNING
							FIXE=yes
						fi
						# Major
						if [ "$NEW_MAJOR" -gt "$PKG_MAJOR" ] 2> /dev/null; then
							RELEASE=major
							FIXE=""
						fi
						if [ "$NEW_MAJOR" -lt "$PKG_MAJOR" ] 2> /dev/null; then
							RELEASE=$WARNING
							FIXE=yes
						fi
						# Default to revision.
						if [ -z $RELEASE ]; then
							RELEASE=revision
						fi
						# Pkg name is already displayed by the check process.
						echo -en "\033[24G $VERSION"
						echo -en "\033[38G --->"
						echo -en "\033[43G $NEW_VERSION"
						echo -en "\033[58G $CATEGORY"
						echo -e "\033[72G $RELEASE"
						up=$(($up+1))
						echo "$PACKAGE" >> upgradeable-packages.list
						case "$FIRST_CLASS_PACKAGE" in
						*\ $PACKAGE\ *) echo "$PACKAGE" >> upgradeable-packages.list$$;;
						esac
						unset RELEASE
					fi
					packages=$(($packages+1))
				fi
			fi
		done
		if [ -z $blocked ]; then
			blocked=0
		fi
		# Clean last checked package and display summary.
		if [ ! "$up" = "" ]; then
			echo -e "\\033[0G                                         "
			echo "================================================================================"
			echo "$packages installed and listed packages to consider, $up to upgrade, $blocked blocked."
			echo ""
		else
			echo -e "\\033[0GSystem is up-to-date.                    "
			echo ""
			echo "================================================================================"
			echo "$packages installed and listed packages to consider, 0 to upgrade, $blocked blocked."
			echo ""
			exit 0
		fi
		# What to do if major or minor version is smaller.
		if [ "$FIXE" == "yes" ]; then
			echo -e "$WARNING ---> Installed package seems more recent than the mirrored one."
			echo "You can block packages using the command : 'tazpkg block package'"
			echo "Or upgrade packages at your own risk."
			echo ""
		fi
		# Ask for upgrade, it can be done another time.
		echo -n "Upgrade now (y/N) ? "; read anser
		if [ ! "$anser" = "y" ]; then
			echo -e "\nExiting. No package upgraded.\n"
			exit 0
		fi
		# If anser is yes (y). Install all new versions.
		cat upgradeable-packages.list >> upgradeable-packages.list$$
		mv -f upgradeable-packages.list$$ upgradeable-packages.list
		yes y | tazpkg get-install-list upgradeable-packages.list --forced
		rm -f upgradeable-packages.list
		;;
	bugs)
		# Show known bugs in package(s)
		#
		cd $INSTALLED
		shift
		LIST=$@
		[ -n "$LIST" ] || LIST=`ls`
		MSG="No known bugs."
		for PACKAGE in $LIST; do
			BUGS=""
			EXTRAVERSION=""
			. $PACKAGE/receipt
			if [ -n "$BUGS" ]; then
				MSG="
Bug list completed"
				cat <<EOT

Bugs in package $PACKAGE version $VERSION$EXTRAVERSION:
  $BUGS
EOT
			fi
		done
		echo "$MSG" ;;
	check)
		# Check installed packages set.
		#
		check_root
		cd $INSTALLED
		for PACKAGE in `ls`; do
			if [ ! -f $PACKAGE/receipt ]; then
				echo "The package $PACKAGE installation has not completed"
				continue
			fi
			DEPENDS=""
			EXTRAVERSION=""
			. $PACKAGE/receipt
			if [ -s $PACKAGE/modifiers ]; then
				echo "The package $PACKAGE $VERSION$EXTRAVERSION has been modified by :"
				for i in $(cat $PACKAGE/modifiers); do
					echo "  $i"
				done
			fi
			MSG="Files lost from $PACKAGE $VERSION$EXTRAVERSION :\n"
			while read file; do
				[ -e "$file" ] && continue
				if [ -L "$file" ]; then
					MSG="$MSG  target of symlink"
				fi
				echo -e "$MSG  $file"
				MSG=""
			done < $PACKAGE/files.list
			MSG="Missing dependencies for $PACKAGE $VERSION$EXTRAVERSION :\n"
			for i in $DEPENDS; do
				[ -d $i ] && continue
				[ -d $(equivalent_pkg $i) ] && continue
				echo -e "$MSG  $i"
				MSG=""
			done
			MSG="Dependencies loop between $PACKAGE and :\n"
			ALL_DEPS=""
			check_for_deps_loop $PACKAGE $DEPENDS
		done
		echo -n "Looking for known bugs... "
		tazpkg bugs
		if [ "$PACKAGE_FILE" = "--full" ]; then
			for file in */md5sum; do
				CONFIG_FILES=""
				. $(dirname "$file")/receipt
				[ -s "$file" ] || continue
				while read md5 f; do
					[ -f $f ] || continue
					for i in $CONFIG_FILES; do
						case "$f" in
						$i|$i/*) continue 2;;
						esac
					done
					echo "$md5  $f"
				done < "$file" | md5sum -c - 2> /dev/null | \
				  grep -v OK$ | sed 's/FAILED$/MD5SUM MISMATCH/'
			done
			FILES=" "
			for file in $(cat */files.list); do
				[ -d "$file" ] && continue
				case "$FILES" in *\ $file\ *) continue;; esac
				[ $(grep "^$file$" */files.list 2> /dev/null | \
					wc -l) -gt 1 ] || continue
				FILES="$FILES$file "
				echo "The following packages provide $file :"
				grep -l "^$file$" */files.list | while read f
				do
					pkg=${f%/files.list}
					echo -n "  $pkg"
					if [ -f $pkg/modifiers ]; then
						echo -n " (overridden by $(echo "$(cat $pkg/modifiers)"))"
					fi
					echo ""
				done
			done
			MSG="No package has installed the following files:\n"
			find /etc /bin /sbin /lib /usr /var/www \
				-not -type d 2> /dev/null | while read file; do
				case "$file" in *\[*) continue;; esac
				grep -q "^$file$" */files.list && continue
				echo -e "$MSG  $file"
				MSG=""
			done
		fi
		echo "Check completed." ;;
	block)
		# Add a pkg name to the list of blocked packages.
		#
		check_root
		check_for_package_on_cmdline
		echo ""
		if grep -qs "^$PACKAGE" $BLOCKED; then
			echo "$PACKAGE is already in the blocked packages list."
			echo ""
			exit 0
		else
			echo -n "Add $PACKAGE to : $BLOCKED..."
			echo $PACKAGE >> $BLOCKED
			status
			# Log this activity
			. $INSTALLED/$PACKAGE/receipt
			log Blocked
		fi
		echo "" ;;
	unblock)
		# Remove a pkg name from the list of blocked packages.
		#
		check_root
		check_for_package_on_cmdline
		echo ""
		if grep -qs "^$PACKAGE" $BLOCKED; then
			echo -n "Removing $PACKAGE from : $BLOCKED..."
			sed -i s/$PACKAGE/''/ $BLOCKED
			sed -i '/^$/d' $BLOCKED
			status
			# Log this activity
			. $INSTALLED/$PACKAGE/receipt
			log Unblocked
		else
			echo "$PACKAGE is not in the blocked packages list."
			echo ""
			exit 0
		fi
		echo "" ;;
	get)
		# Downlowd a package with wget.
		#
		check_for_package_on_cmdline
		check_for_packages_list
		check_for_package_in_list
		echo ""
		download $PACKAGE.tazpkg
		echo "" ;;
	get-install)
		# Download and install a package.
		#
		AUTO_INSTALL_DEPS="yes"
		check_root
		check_for_package_on_cmdline
		check_for_packages_list
		DO_CHECK=""
		while [ -n "$3" ]; do
			case "$3" in
			--forced)
				DO_CHECK="no"
				;;
			--root=*)
				ROOT="${3#--root=}"
				;;
			--list=*)
				INSTALL_LIST="${3#--list=}"
				;;
			*)	shift 2
				echo -e "\nUnknown option $*.\n"
				exit 1
				;;
			esac
			shift
		done
		AUTOEXEC="no"
		if ! check_for_package_in_list check; then
			PACKAGE=get-$PACKAGE
			AUTOEXEC=$PACKAGE
			check_for_package_in_list
			if [ -n "$(get_installed_package_pathname $PACKAGE $ROOT)" ]; then
				$AUTOEXEC $ROOT
				exit 0
			fi
		fi
		# Check if forced install.
		if [ "$DO_CHECK" = "no" ]; then
			rm -f $CACHE_DIR/$PACKAGE.tazpkg
		else
			check_for_installed_package $ROOT
		fi
		cd $CACHE_DIR
		if [ -f "$PACKAGE.tazpkg" ]; then
			echo "$PACKAGE already in the cache : $CACHE_DIR"
			# Check package download was finished
			tail -c 2k $PACKAGE.tazpkg | grep -q 00000000TRAILER || {
				echo "Continue $PACKAGE download"
				download $PACKAGE.tazpkg
			}
		else
			echo ""
			download $PACKAGE.tazpkg
		fi
		PACKAGE_FILE=$CACHE_DIR/$PACKAGE.tazpkg
		install_package $ROOT
		[ "$AUTOEXEC" != "no" ] && $PACKAGE $ROOT ;;
	clean-cache)
		# Remove all downloaded packages.
		#
		check_root
		files=`ls -1 $CACHE_DIR | wc -l`
		echo ""
		echo -e "\033[1mClean cache :\033[0m $CACHE_DIR"
		echo "================================================================================"
		echo -n "Cleaning cache directory..."
		rm -rf $CACHE_DIR/*
		status
		echo "================================================================================"
		echo "$files file(s) removed from cache."
		echo "" ;;
	list-undigest)
		# list undigest URLs.
		#
		if [ "$2" = "--box" ]; then
			for i in $LOCALSTATE/undigest/*/mirror; do
				[ -f $i ] || continue
				echo "$(basename $(dirname $i))|$(cat $i)"
			done
		else
			echo ""
			echo -e "\033[1mCurrent undigest(s)\033[0m"
			echo "================================================================================"
			for i in $LOCALSTATE/undigest/*/mirror; do
				if [ ! -f $i ]; then
					echo "No undigest mirror found."
					exit 1
				fi
				echo "$(basename $(dirname $i))	$(cat $i)"
			done
			echo ""
		fi ;;
	remove-undigest)
		# remove undigest URL.
		#
		check_root
		if [ -d $LOCALSTATE/undigest/$2 ]; then
			echo -n "Remove $2 undigest (y/N) ? "; read anser
			if [ "$anser" = "y" ]; then
				echo -n "Removing $2 undigest..."
				rm -rf $LOCALSTATE/undigest/$2
				status
				rmdir $LOCALSTATE/undigest 2> /dev/null
			fi
		else
			echo "Undigest $2 not found"
		fi ;;
	add-undigest|setup-undigest)
		# Add undigest URL.
		#
		check_root
		undigest=$2
		[ -d $LOCALSTATE/undigest ] || mkdir $LOCALSTATE/undigest
		if [ -z "$undigest" ]; then
			i=1
			while [ -d $LOCALSTATE/undigest/$i ]; do
				i=$(($i+1))
			done
			undigest=$i
		fi
		if [ ! -d $LOCALSTATE/undigest/$undigest ]; then
			echo "Creating new undigest $undigest."
			mkdir $LOCALSTATE/undigest/$undigest
		fi
		setup_mirror $LOCALSTATE/undigest/$undigest $3 ;;
	setup-mirror)
		# Change mirror URL.
		#
		check_root
		setup_mirror $LOCALSTATE $2 ;;
	reconfigure)
		# Replay post_install from receipt
		#
		check_for_package_on_cmdline
		check_root
		ROOT=""
		while [ -n "$3" ]; do
			case "$3" in
			--root=*)
				ROOT="${3#--root=}/" ;;
			*)	shift 2
				echo -e "\nUnknown option $*.\n"
				exit 1 ;;
			esac
			shift
		done
		if [ -d "$ROOT$INSTALLED/$PACKAGE" ]; then
			check_for_receipt $ROOT
			# Check for post_install
			if grep -q ^post_install $ROOT$INSTALLED/$PACKAGE/receipt; then
				. $ROOT$INSTALLED/$PACKAGE/receipt
				post_install $ROOT
				# Log this activity
				[ -n "$ROOT" ] || log Reconfigured
			else
				echo -e "\nNothing to do for $PACKAGE."
			fi
		else
			echo -e "\npackage $PACKAGE is not installed."
			echo -e "Install package with 'tazpkg install' or 'tazpkg get-install'\n"
		fi ;;
	shell)
		# Tazpkg SHell
		#
		if test $(id -u) = 0 ; then
			PROMPT="\\033[1;33mtazpkg\\033[0;39m# "
		else
			PROMPT="\\033[1;33mtazpkg\\033[0;39m> "
		fi
		if [ ! "$2" = "--noheader" ]; then
			clear
			echo ""
			echo -e "\033[1mTazpkg SHell.\033[0m"
			echo "================================================================================"
			echo "Type 'usage' to list all available commands or 'quit' or 'q' to exit."
			echo ""
		fi
		while true
		do
			echo -en "$PROMPT"; read cmd
			case $cmd in
				q|quit)
					break ;;
				shell)
					echo "You are already running a Tazpkg SHell." ;;
				su)
					su -c 'exec tazpkg shell --noheader' && break ;;
				"")
					continue ;;
				*)
					tazpkg $cmd ;;
			esac
		done ;;
	depends)
		# Display dependencies tree
		cd $INSTALLED
		ALL_DEPS=""
		if [ -f $2/receipt ]; then
			dep_scan $2 ""
		fi ;;
	rdepends)
		# Display reverse dependencies tree
		cd $INSTALLED
		ALL_DEPS=""
		if [ -f $2/receipt ]; then
			rdep_scan $2
		fi ;;
	convert)
		# convert misc package format to .tazpkg
		check_for_package_file
		case "$PACKAGE_FILE" in
		*.deb|*.udeb)
			convert_deb;;
		*.rpm)
			convert_rpm;;
		*.tgz)
			convert_tgz;;
		*.pkg.tar.gz)
			convert_arch;;
		*.ipk|*.opk)
			convert_ipk;;
		*)
			echo "Unsupported format";;
		esac ;;
	link)
		# link a package from another slitaz installation
		PACKAGE=$2
		if [ ! -d "$TARGET_DIR" -o \
		     ! -d "$TARGET_DIR$INSTALLED/$PACKAGE" ]; then
			cat <<EOT
usage:   tazpkg link package_name slitaz_root
example: 'tazpkg link openoffice /mnt' will use less than 100k in
         your ram running system.
EOT
			exit 1
		fi
		if [ -e "$INSTALLED/$PACKAGE" ]; then
			echo "$PACKAGE is already installed."
			exit 1
		fi
		ln -s $TARGET_DIR$INSTALLED/$PACKAGE $INSTALLED
		DEPENDS="$(. $INSTALLED/$PACKAGE/receipt ; echo $DEPENDS)"
		MISSING=""
		for i in $DEPENDS; do
			[ -e $INSTALLED/$i ] && continue
			MISSING="$MISSING$i "
			echo "Missing : $i"
		done
		if [ -n "$MISSING" ]; then
			echo ""
			echo -n "Link all missing dependencies (y/N) ? "; read answer
			echo ""
			if [ "$answer" = "y" ]; then
				for i in $MISSING; do
					tazpkg link $i $TARGET_DIR
				done
			else
				echo -e "\nLeaving dependencies for $PACKAGE unsolved."
				echo -e "The package is installed but will probably not work.\n"
			fi
		fi
		. $INSTALLED/$PACKAGE/receipt
		if grep -q ^pre_install $INSTALLED/$PACKAGE/receipt; then
			pre_install
		fi
		while read path; do
			[ -e $path ] && continue
			while true; do
				dir=$(dirname $path)
				[ -e $dir ] && break
				path=$dir
			done
			ln -s $TARGET_DIR$path $dir
		done < $INSTALLED/$PACKAGE/files.list
		if grep -q ^post_install $INSTALLED/$PACKAGE/receipt; then
			post_install
		fi ;;
	usage|*)
		# Print a short help or give usage for an unknown or empty command.
		usage ;;
esac

exit 0
